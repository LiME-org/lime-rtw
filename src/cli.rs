//! Command line argument parsing.
//!
//! This module defines various structures dealing with command line argument
//! parsing. The `CLI` structure is the main structure representing command line
//! arguments. It can be constructed as follow:
//!
//! ```no_run
//! use lime_rtw::cli::CLI;
//! use clap::Parser;
//!
//! let args = CLI::parse();
//! ```
//! The CLI structure is rarely used as if. Instead, it is converted to a
//! `LimeContext` first. Please see the context module.
//!

use std::time::Duration;

use crate::trace::writer::EventsFileFormat;
use clap::{Parser, Subcommand};
use duration_str::DResult;

fn parse_duration(s: &str) -> DResult<Duration> {
    duration_str::parse(s)
}

#[derive(Debug, Parser)]
#[clap(trailing_var_arg = true)]
#[command(about, version)]
pub struct CLI {
    /// Verbose debug output
    #[clap(short, long)]
    pub verbose: bool,

    /// Contains the lime's command arguments.
    #[clap(subcommand)]
    pub command: LimeSubCommand,
}

/// Source of events determined from the lime command arguments.
pub enum EventSourceType {
    #[cfg(target_os = "linux")]
    BPFTracer,
    TraceFolder(String),
}

#[derive(Debug, Subcommand)]
pub enum LimeSubCommand {
    /// Record and dump a trace in json format
    #[cfg(target_os = "linux")]
    Trace {
        /// Path to the output directory. The directory must not already exists.
        /// If this option is not set, an output directory will be created in
        /// the current working directory.
        #[clap(short)]
        output: Option<String>,

        /// Output format (json or protobuf), only apply to events files
        #[clap(long, default_value = "json")]
        format: EventsFileFormat,

        /// Do not filter by child TGID if a command is specified
        #[clap(long = "all")]
        trace_all: bool,

        /// Trace events emitted by CFS tasks.
        #[clap(long = "cfs")]
        trace_cfs: bool,

        /// EBPF ring buffer poll interval
        #[clap(long, value_parser = parse_duration, default_value="10ms")]
        ebpf_poll_interval: Duration,

        #[clap(long, value_parser = parse_duration, default_value="0s")]
        rate_limiter_period: Duration,

        #[clap(long, default_value = "0")]
        rate_limiter_budget: usize,

        /// Do not update task id on affinity change
        #[clap(long)]
        allow_task_affinity_change: bool,

        /// Do not update task id on priority change
        #[clap(long)]
        allow_task_priority_change: bool,

        /// Command to trace. By default, only the events generated by the invoked command and its child will be traced.
        /// Note that scheduling policy still apply.
        /// If none is given lime-rtw will trace until
        /// it receives SIGINT.
        cmd: Vec<String>,

        /// Event batch size for processing
        #[clap(long, default_value = "4096")]
        tx_batch_size: usize,
    },

    /// Observe the system and extract a workload model.
    Extract {
        /// Path to the output directory. The directory must not already exists.
        /// If this option is not set, an output directory will be created in
        /// the current working directory.
        #[clap(short)]
        output: Option<String>,

        /// Do not update task id on affinity change
        #[clap(long)]
        allow_task_affinity_change: bool,

        /// Do not update task id on priority change
        #[clap(long)]
        allow_task_priority_change: bool,

        /// Path to a trace folder. If this option is specified, then the tracer
        /// will not be launched and extraction will be performed from the
        /// specified trace instead.
        #[clap(short, long)]
        from: Option<String>,

        /// Save the extraction in the trace folder if the event source is
        /// a recorded trace. Ignored otherwise.
        #[clap(long)]
        inplace: bool,

        /// Max window length for WCET(n)
        #[clap(long, default_value = "32")]
        wcet_n_max_len: usize,

        #[clap(long, default_value = "32")]
        arrival_curve_max_len: usize,

        /// Enable the Request Bound Function (RBF) extraction.
        /// By default, this flag is set to `false` to reduce
        /// overhead unless RBF extraction is needed.
        #[clap(long, default_value_t = false)]
        enable_rbf: bool,

        #[clap(long, default_value = "100")]
        rbf_max_steps: usize,

        // RBF horizon. Disabled if set to zero.
        #[clap(long, value_parser = parse_duration, default_value="10s")]
        rbf_horizon: Duration,

        #[clap(long, default_value = "500000")]
        rbf_min_sep: u64,

        /// Do not update the RBF until a job separation (other than a suspension) has been detected.
        #[clap(long)]
        rbf_no_init: bool,

        #[clap(long, value_parser = parse_duration, default_value="60s")]
        rate_limiter_period: Duration,

        #[clap(long, default_value = "1200000")]
        rate_limiter_budget: usize,

        /// Do not filter by child TGID if a command is specified
        #[cfg(target_os = "linux")]
        #[clap(long = "all")]
        trace_all: bool,

        /// Extract models for CFS tasks.
        #[clap(long = "cfs")]
        trace_cfs: bool,

        /// EBPF ring buffer poll interval
        #[clap(long, value_parser = parse_duration, default_value="10ms")]
        ebpf_poll_interval: Duration,

        /// Report all threads, even short-lived ones for which no
        /// meaningful model could be inferred.
        #[clap(long)]
        all_threads: bool,

        #[clap(long, default_value = "200")]
        period_extractor_batch_size: usize,

        /// Event batch size for processing
        #[clap(long, default_value = "4096")]
        tx_batch_size: usize,

        /// Command to trace. By default, only the events generated by the invoked command and its child will be traced.
        /// Note that scheduling policy still apply.
        /// If none is given lime-rtw will trace until
        /// it receives SIGINT.
        #[cfg(target_os = "linux")]
        cmd: Vec<String>,
    },

    /// Observe the system and extract a workload model.
    ExtractJobs {
        /// Path to the output directory. The directory must not already exists.
        /// If this option is not set, an output directory will be created in
        /// the current working directory.
        #[clap(short)]
        output: Option<String>,

        /// Path to a trace folder.
        /// This argument is required, since job extraction is only possible on recorded traces.
        #[clap(short, long)]
        from: String,

        /// Save the extraction in the trace folder if the event source is
        /// a recorded trace. Ignored otherwise.
        #[clap(long)]
        inplace: bool,
    },
}

impl CLI {
    #[cfg(target_os = "linux")]
    pub fn get_cmd_vec(&self) -> Option<&Vec<String>> {
        match &self.command {
            LimeSubCommand::Trace { cmd, .. } => Some(cmd).filter(|v| !v.is_empty()),
            LimeSubCommand::Extract { cmd, .. } => Some(cmd).filter(|v| !v.is_empty()),
            _ => None,
        }
    }

    #[cfg(not(target_os = "linux"))]
    pub fn get_cmd_vec(&self) -> Option<&Vec<String>> {
        None
    }

    #[cfg(target_os = "linux")]
    pub fn trace_all(&self) -> bool {
        match &self.command {
            LimeSubCommand::Trace { trace_all, .. } => *trace_all,
            LimeSubCommand::Extract { trace_all, .. } => *trace_all,
            _ => false,
        }
    }

    #[cfg(not(target_os = "linux"))]
    pub fn trace_all(&self) -> bool {
        false
    }

    pub fn trace_cfs(&self) -> bool {
        match &self.command {
            #[cfg(target_os = "linux")]
            LimeSubCommand::Trace { trace_cfs, .. } => *trace_cfs,
            LimeSubCommand::Extract { trace_cfs, .. } => *trace_cfs,
            _ => false,
        }
    }

    pub fn ebpf_poll_interval(&self) -> Duration {
        match &self.command {
            #[cfg(target_os = "linux")]
            LimeSubCommand::Trace {
                ebpf_poll_interval, ..
            } => *ebpf_poll_interval,
            LimeSubCommand::Extract {
                ebpf_poll_interval, ..
            } => *ebpf_poll_interval,
            _ => Duration::from_millis(10),
        }
    }

    pub fn all_threads(&self) -> bool {
        match &self.command {
            #[cfg(target_os = "linux")]
            LimeSubCommand::Extract { all_threads, .. } => *all_threads,
            _ => false,
        }
    }

    pub fn event_source_type(&self) -> EventSourceType {
        match &self.command {
            #[cfg(target_os = "linux")]
            LimeSubCommand::Trace { .. } | LimeSubCommand::Extract { from: None, .. } => {
                EventSourceType::BPFTracer
            }

            #[cfg(not(target_os = "linux"))]
            LimeSubCommand::Extract { from: None, .. } => unreachable!(),

            LimeSubCommand::Extract {
                from: Some(path), ..
            } => EventSourceType::TraceFolder(path.clone()),

            LimeSubCommand::ExtractJobs { from: path, .. } => {
                EventSourceType::TraceFolder(path.clone())
            }
        }
    }

    pub fn in_place(&self) -> bool {
        match &self.command {
            LimeSubCommand::Extract { inplace, .. } => *inplace,
            LimeSubCommand::ExtractJobs { inplace, .. } => *inplace,
            #[cfg(target_os = "linux")]
            _ => false,
        }
    }

    pub fn output_dir(&self) -> Option<String> {
        if self.in_place() {
            match &self.command {
                LimeSubCommand::Extract { from, .. } => return from.clone(),
                LimeSubCommand::ExtractJobs { from, .. } => return Some(from.clone()),
                #[cfg(target_os = "linux")]
                _ => {}
            }
        }

        match &self.command {
            #[cfg(target_os = "linux")]
            LimeSubCommand::Trace { output, .. } => output.clone(),
            LimeSubCommand::Extract { output, .. } => output.clone(),
            LimeSubCommand::ExtractJobs { output, .. } => output.clone(),
        }
    }

    pub fn wcet_n_max_len(&self) -> Option<usize> {
        match &self.command {
            LimeSubCommand::Extract { wcet_n_max_len, .. } => Some(*wcet_n_max_len),
            _ => None,
        }
    }

    pub fn arrival_curve_max_len(&self) -> Option<usize> {
        match &self.command {
            LimeSubCommand::Extract {
                arrival_curve_max_len,
                ..
            } => Some(*arrival_curve_max_len),
            _ => None,
        }
    }

    pub fn enable_rbf(&self) -> bool {
        match &self.command {
            LimeSubCommand::Extract { enable_rbf, .. } => *enable_rbf,
            _ => false,
        }
    }

    pub fn rbf_max_steps(&self) -> Option<usize> {
        match &self.command {
            LimeSubCommand::Extract { rbf_max_steps, .. } => Some(*rbf_max_steps),
            _ => None,
        }
    }

    pub fn rbf_no_update_init(&self) -> Option<bool> {
        match &self.command {
            LimeSubCommand::Extract {
                rbf_no_init: rbf_no_update_init,
                ..
            } => Some(*rbf_no_update_init),
            _ => None,
        }
    }

    pub fn rbf_min_sep(&self) -> Option<u64> {
        match &self.command {
            LimeSubCommand::Extract { rbf_min_sep, .. } => Some(*rbf_min_sep),
            _ => None,
        }
    }

    /// RBF horizon in nanoseconds. Set to 0 for infinite horizon.
    pub fn rbf_horizon(&self) -> Option<u64> {
        match &self.command {
            LimeSubCommand::Extract { rbf_horizon, .. } if !rbf_horizon.is_zero() => {
                Some(rbf_horizon.as_nanos() as u64)
            }
            _ => None,
        }
    }

    pub fn rate_limiter_budget(&self) -> Option<usize> {
        match &self.command {
            LimeSubCommand::Extract {
                rate_limiter_budget,
                ..
            } => Some(*rate_limiter_budget),
            #[cfg(target_os = "linux")]
            LimeSubCommand::Trace {
                rate_limiter_budget,
                ..
            } => Some(*rate_limiter_budget),
            _ => None,
        }
    }

    pub fn rate_limiter_period(&self) -> Option<Duration> {
        match &self.command {
            LimeSubCommand::Extract {
                rate_limiter_period,
                ..
            } => Some(*rate_limiter_period),
            #[cfg(target_os = "linux")]
            LimeSubCommand::Trace {
                rate_limiter_period,
                ..
            } => Some(*rate_limiter_period),
            _ => None,
        }
    }
    pub fn period_extractor_batch_size(&self) -> usize {
        match self.command {
            LimeSubCommand::Extract {
                period_extractor_batch_size: period_extracor_batch_size,
                ..
            } => period_extracor_batch_size,
            _ => 0,
        }
    }

    pub fn allow_task_affinity_change(&self) -> bool {
        match self.command {
            LimeSubCommand::Extract {
                allow_task_affinity_change,
                ..
            } => allow_task_affinity_change,
            #[cfg(target_os = "linux")]
            LimeSubCommand::Trace {
                allow_task_affinity_change,
                ..
            } => allow_task_affinity_change,
            _ => false,
        }
    }

    pub fn allow_task_priority_change(&self) -> bool {
        match self.command {
            LimeSubCommand::Extract {
                allow_task_priority_change,
                ..
            } => allow_task_priority_change,
            #[cfg(target_os = "linux")]
            LimeSubCommand::Trace {
                allow_task_priority_change,
                ..
            } => allow_task_priority_change,
            _ => false,
        }
    }

    pub fn tx_batch_size(&self) -> usize {
        match &self.command {
            #[cfg(target_os = "linux")]
            LimeSubCommand::Trace { tx_batch_size, .. } => *tx_batch_size,
            LimeSubCommand::Extract { tx_batch_size, .. } => *tx_batch_size,
            _ => 4 * 1024,
        }
    }

    pub fn output_format(&self) -> EventsFileFormat {
        match &self.command {
            #[cfg(target_os = "linux")]
            LimeSubCommand::Trace {
                format: output_format,
                ..
            } => *output_format,
            _ => EventsFileFormat::Json, // Default to JSON for other commands
        }
    }
}

#[cfg(test)]
mod tests {
    #[cfg(target_os = "linux")]
    use crate::cli::{LimeSubCommand, CLI};
    #[cfg(target_os = "linux")]
    use clap::Parser;

    #[cfg(target_os = "linux")]
    #[test]
    fn test_cli_trace() {
        let cmd = ["lime-rtw", "trace", "--", "a", "b", "c"];

        let cli = CLI::parse_from(cmd.iter());

        match cli.command {
            LimeSubCommand::Trace {
                output,
                cmd,
                trace_all,
                ..
            } => {
                assert!(output.is_none());
                assert!(cmd.len() == 3);
                assert!(!trace_all)
            }
            _ => unreachable!(),
        }

        let cmd = ["lime-rtw", "trace", "--all", "--", "a", "b", "c"];

        let cli = CLI::parse_from(cmd.iter());

        match cli.command {
            LimeSubCommand::Trace {
                output,
                cmd,
                trace_all,
                ..
            } => {
                assert!(output.is_none());
                assert!(cmd.len() == 3);
                assert!(trace_all)
            }
            _ => unreachable!(),
        }

        let cmd = ["lime-rtw", "-v", "trace", "--", "a", "b", "c"];

        let cli = CLI::parse_from(cmd.iter());

        assert!(cli.verbose);

        match cli.command {
            LimeSubCommand::Trace {
                output,
                cmd,
                trace_all,
                ..
            } => {
                assert!(output.is_none());
                assert!(cmd.len() == 3);
                assert!(!trace_all)
            }
            _ => unreachable!(),
        }

        let cmd = ["lime-rtw", "trace", "-o", "toto.json", "--", "a", "b", "c"];

        let cli = CLI::parse_from(cmd.iter());

        match cli.command {
            LimeSubCommand::Trace { output, cmd, .. } => {
                assert!(output.unwrap() == "toto.json");
                assert!(cmd.len() == 3);
            }
            _ => unreachable!(),
        }
    }
}
